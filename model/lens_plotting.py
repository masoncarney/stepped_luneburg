import os, sys
import numpy as np
import pylab as pl

def draw_ray(p, d, t, plotray):
    '''Uses a point in 3D space, direction vector, and value generated by sphere_hit() to draw a line from the initial point to a point of intersection with a sphere and returns the point of intersection with a sphere.
    
    ==========
    Parameters

    p: [array of floats] initial point in 3D space at [x,y,z] for line plotting
    
    d: [array of floats] direction vector [x,y,z] for line plotting
    
    t: [float] value to test for the vector-sphere intersection between point p and the nearest sphere, as calculated by sphere_hit()
    
    plotray: [boolean True/False] option to plot the ray; taken from stepped_luneburg(plot=True/False) parameter

    ==========    
    '''
    
    # draw a line from p0 to p0 + d0
    p1 = p + t*d

    if (t > 0. and plotray==True):
        xpts = np.array([p[0],p1[0]])
        ypts = np.array([p[1],p1[1]])
        pl.plot(xpts,ypts,color='k',lw=0.5)
        pl.plot(p1[0],p1[1],color='r',marker='o',ms=2.0,mew=0.)

    return(p1)

def draw_sph(c,r,zord):
    '''Draws sphere with given center and radius.

    ==========
    Parameters

    c: [array of floats] center of sphere at [x,y,z]
    
    r: [float] radius of sphere to be drawn
    
    zord: [int] zorder parameter for pl.plot(), adjust plotting order of figure
    
    ==========        
    '''
    
    theta = np.arange(0.,2.*np.pi+1.e-3,np.pi/10.)
    phi = np.arange(0.,np.pi+1.e-3,np.pi/10.)

    x = np.zeros(len(theta)*len(phi))
    y = np.zeros(len(theta)*len(phi))
    z = np.zeros(len(theta)*len(phi))
    k = 0

    for i in np.arange(0,len(theta)):
        for j in np.arange(0,len(phi)):

            x[k] = r*np.cos(theta[i])*np.sin(phi[j])+c[0]
            y[k] = r*np.sin(theta[i])*np.sin(phi[j])+c[1]
            z[k] = r*np.cos(phi[j])+c[2]

            k+=1
    
    x_pl = x[np.where(abs(z)<1.e-10)]
    y_pl = y[np.where(abs(z)<1.e-10)]  
    
    pl.plot(x_pl,y_pl,'c-',zorder=zord)
    pl.axis('equal')
    

def draw_sph_2Dproj(c,r,zord):
    '''Marks points for a 2D projection from polar to cartesian of sphere with given center and radius.

    ==========
    Parameters

    c: [array of floats] center of sphere at [x,y,z]
    
    r: [float] radius of sphere to be drawn in 2D projection
    
    zord: [int] zorder parameter for pl.plot(), adjust plotting order of figure
    
    ==========        
    '''
    
    theta = np.arange(0.,2.*np.pi+1.e-3,np.pi/10.)
    phi = np.arange(0.,np.pi+1.e-3,np.pi/10.)

    x = np.zeros(len(theta)*len(phi))
    y = np.zeros(len(theta)*len(phi))
    z = np.zeros(len(theta)*len(phi))
    k = 0

    for i in np.arange(0,len(theta)):
        for j in np.arange(0,len(phi)):

            x[k] = r*np.cos(theta[i])*np.sin(phi[j])+c[0]
            y[k] = r*np.sin(theta[i])*np.sin(phi[j])+c[1]
            z[k] = r*np.cos(phi[j])+c[2]

            k+=1

    # convert polar coordinates to cartesian for plotting
            
    r = np.sqrt( (x*x) + (y*y) + (z*z) )
    d = np.sqrt( (x*x) + (y*y) )
    theta = np.arctan2(y,x)
    
    if(r[0] != 0.):
    
        xplot = np.sin(theta) * np.arcsin(d/r) * 2. / np.pi
        yplot = np.cos(theta) * np.arcsin(d/r) * 2. / np.pi

        pl.plot(xplot,yplot,'ko',markersize=0.5,zorder=zord)
        pl.axis('equal')

########################################################################
